@page "/search/{machineUrl}"
@using Wabbajack.DTOs.ServerResponses
@using Wabbajack.Web.Pages.Gallery
@using Wabbajack.Web.Services
@using Wabbajack.Web.Utils
@using Wabbajack.DTOs.DownloadStates
@using Wabbajack.DTOs
@using Wabbajack.DTOs.ModListValidation
@using Wabbajack.Common
@inject IStateContainer _stateContainer;
@inject NavigationManager _navigationManager;

<div class="md:m-8">
    @if (_modlistStatus == null)
    {
        @if (_errorFoundNoMatchingModlist)
        {
            @ErrorComponent.RenderError($"Found no Modlist with machineUrl {MachineUrl}")
        }
        else
        {
            @LoadingComponent.RenderLoadingThing("Loading Modlist...")
        }
    }
    else
    {
        <from>
            <label for="search-archive">Name:</label>
            <input class="text-black-900 sm:text-sm p-1" @bind="_searchString" id="search-archive" type="search" maxlength="100"/>
        </from>

        <div class="w-full overflow-hidden">
            <div class="p-4 w-full overflow-x-auto">
                <table class="w-full">
                    <thead>
                    <tr class="text-md font-semibold tracking-wide text-left bg-black-700">
                        <th class="px-4 py-3">Action</th>
                        <th class="px-4 py-3">Name</th>
                        <th class="px-4 py-3">Archive Name</th>
                        <th class="px-4 py-3">Size</th>
                    </tr>
                    </thead>
                    <tbody>
                    @foreach (var archive in Archives)
                    {
                        <tr @key="archive.Name" class="bg-black-600">
                            @_renderRow(archive)
                        </tr>
                    }
                    </tbody>
                </table>
            </div>
        </div>
    }
</div>

@code {
    [Parameter]
    public string MachineUrl { get; set; }

    private bool _shouldRender;
    protected override bool ShouldRender() => _shouldRender;

    private bool _errorFoundNoMatchingModlist;

    private ValidatedModList _modlistStatus;
    private IEnumerable<Archive> Archives => _modlistStatus.Archives
        .Select(x => x.Original)
        .Where(ShouldRenderArchive);

    private string _searchString;

    protected override async Task OnInitializedAsync()
    {
        if (MachineUrl == null) return;

        if (!_stateContainer.TryGetModlistStatus(MachineUrl, out _modlistStatus))
        {
            var res = await _stateContainer.LoadModlistStatus(MachineUrl);

            if (res == null)
            {
                _errorFoundNoMatchingModlist = true;
                _shouldRender = true;
                return;
            }

            _modlistStatus = res;
        }

        _shouldRender = true;
    }

    // DO NOT CHANGE "__builder"
    // ReSharper disable InconsistentNaming
    // ReSharper disable once UnusedParameter.Local
    private static readonly RenderFragment<Archive> _renderRow = archive => __builder =>
    {
        <td class="px-4 font-light">
            <a href="https://github.com/ModOrganizer/ModOrganizer2">Open</a>
        </td>
        <td class="px-4 font-light">@GetMetaName(archive)</td>
        <td class="px-4 font-light">@archive.Name</td>
        <td class="px-4 font-light">@archive.Size.ToFileSizeString()</td>
    };

    private static string GetMetaName(Archive archive)
    {
        var state = archive.State;
        var name = state switch
        {
            Nexus nexusState => nexusState.Name ?? string.Empty,
            IMetaState metaState => metaState.Name ?? string.Empty,
            _ => archive.Name
        };

        return string.IsNullOrEmpty(name) ? archive.Name : name;
    }

    private bool ShouldRenderArchive(Archive archive)
    {
        // returns true if the item should be displayed in the table
        if (string.IsNullOrWhiteSpace(_searchString)) return true;

        var archiveName = archive.Name;
        if (archiveName.Contains(_searchString, StringComparison.OrdinalIgnoreCase)) return true;
        if (GetMetaName(archive).Contains(_searchString, StringComparison.OrdinalIgnoreCase)) return true;
        return false;
    }

    private void OpenArchiveLink(DetailedStatusItem archive)
    {
        var state = archive.Archive.State;
        var url = state switch
        {
            Nexus nexusState => $"https://nexusmods.com/{nexusState.Game.MetaData().NexusName}/mods/{nexusState.ModID}",
            IMetaState metaState => $"{metaState.URL}",
            GoogleDrive googleDriveState => $"https://drive.google.com/file/d/{googleDriveState.Id}",
            Http httpState => $"{httpState.Url}",
            //IPS4OAuth2 ips4State => $"{ips4State.URL}",
            Mega megaState => $"{megaState.Url}",
            _ => null
        };

        if (string.IsNullOrWhiteSpace(url)) return;

        // TODO: open in new tab
        _navigationManager.NavigateTo(url);
    }

    public static string CreateRedirect(string machineUrl) => $"/search/{machineUrl}";
}
